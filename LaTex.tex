\documentclass[12pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{listings}
\usepackage{color}

\title{Факторизация чисел с помощью эллиптических кривых (ECM)}
\author{Мостовской Н.В.}
\date{26.06.2025}

\begin{document}
\maketitle

\section*{Цель работы}
Изучить и реализовать алгоритм Ленстры факторизации чисел с помощью эллиптических кривых (ECM). Сравнить производительность с функцией \texttt{factor()} в системе SageMath.

\section*{Описание алгоритма}
Алгоритм Ленстры использует арифметику на эллиптических кривых над кольцом вычетов по модулю $N$. Идея в том, что при выполнении операций на кривой может возникнуть попытка деления на число, не взаимно простое с $N$. Это число и является нетривиальным делителем.

\section*{Описание машины}
Работа выполнена в браузерной версии SageMath. Операционная система: Windows 10. ОЗУ: 8 ГБ. Процессор: Intel Core i5.

\section*{Псевдокод}
\begin{algorithm}[H]
\caption{ECM – одна попытка}
\begin{algorithmic}[1]
\State Случайно выбираем параметры $x, y, a \in \mathbb{Z}_N$
\State Строим кривую $E: y^2 = x^3 + ax + b \mod N$
\State Проверяем, лежит ли $(x, y)$ на кривой
\State Вычисляем $k = \text{LCM}(2, ..., B)$
\State Пробуем вычислить $kP$ на кривой
\If{возникает ошибка деления}
  \State Делитель найден
\EndIf
\end{algorithmic}
\end{algorithm}

\section*{Исходный код программы}

\begin{lstlisting}[language=Python, basicstyle=\footnotesize\ttfamily]
from random import randint
import time

def Miller_Rabbin(n, k=20)
    r = 0
    d = n - 1
    while d % 2 == 0
        d = 2
        r += 1

    for _ in range(k)
        a = randint(2, n - 2)
        x = pow(a, d, n)
        if x in (1, n - 1)
            continue
        for _ in range(r - 1)
            x = pow(x, 2, n)
            if x == n - 1
                break
        else
            return False
    return True

def ec_add(P, Q, a, N)
    if P == O
        return Q
    if Q == O
        return P

    x1, y1 = P
    x2, y2 = Q

    if x1 == x2 and (y1 + y2) % N == 0
        return O

    if P != Q
        num = (y2 - y1) % N
        den = (x2 - x1) % N
    else
        num = (3  x1  x1 + a) % N
        den = (2  y1) % N

    g = gcd(den, N)
    if g != 1 and g != N
        raise ZeroDivisionError(g)

    try
        inv = pow(den, -1, N)
    except ValueError
        raise ZeroDivisionError(gcd(den, N))

    lam = (num  inv) % N
    x3 = (lam  lam - x1 - x2) % N
    y3 = (lam  (x1 - x3) - y1) % N
    return (x3, y3)


def ec_mul(k, P, a, N)
    R = O
    while k
        if k % 2 == 1
            R = ec_add(R, P, a, N)
        P = ec_add(P, P, a, N)
        k = 2
    return R

def ecm_wiki(N, B, tries)
    for _ in range(tries)
        x = randint(1, N - 1)
        y = randint(1, N - 1)
        a = randint(1, N - 1)
        b = (y  y - x  x  x - a  x) % N

        if (y  y - (x  x  x + a  x + b)) % N != 0
            continue

        P = (x, y)
        k = 1
        for i in range(2, B + 1)
            k = lcm(k, i)

        try
            ec_mul(k, P, a, N)
        except ZeroDivisionError as e
            d = e.args[0]
            if 1  d  N
                return d
    return None

def ecm_full_factor(N, B, tries)
    factors = []

    def recurse(n)
        if n == 1
            return
        if Miller_Rabbin(n)
            factors.append(n)
            return

        d = ecm_wiki(n, B, tries)
        if d is None or d == n
            factors.append(n)
            return
        recurse(d)
        recurse(n  d)

    recurse(N)
    return sorted(factors)

N = 2560000044800000171
start = time.time()
factors = ecm_full_factor(N, B=300, tries=250)
end = time.time()

print(f"Prime factors: {factors}")
print(f"Time: {end - start:.4f} sec")
\end{lstlisting}

\section*{Результаты сравнения}

\begin{tabular}{|c|c|c|}
\hline
Метод & Множители & Время (сек) \\
\hline
ECM & [487, 263521, 20000000359] & 0.14 \\
\hline
Sage \texttt{factor()} & [487, 263521, 20000000359] & 0.01 \\
\hline
\end{tabular}

\section*{Выводы}
Алгоритм Ленстры успешно реализован и протестирован. Он корректно находит делители и пригоден для чисел, устойчивых к другим методам. Однако по производительности уступает встроенному \texttt{factor()} в SageMath.

\end{document}